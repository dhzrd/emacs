#+title: Emacs Literate Config
#+author: Daniel Hazard
#+PROPERTY: header-args :tangle yes
#+PROPERTY: header-args:emacs-lisp :lexical t
#+STARTUP: hidedrawers

GNU Emacs 29.4 (homebrew-emacs-plus)
Org mode version 9.6.15

This ~org~ file tangles to two different ~emacs-lisp~ files in the same directory: ~early-init.el~ and ~init.el~. (See ~header-args~ in the respective ~PROPERTIES~ drawer.)

* early-init.el
:PROPERTIES:
:header-args: :tangle early-init.el
:END:

Emacs loads this file before loading the GUI and package system. Here we declare what GUI elements we want to prevent from initializing. It's also a good place for settings having to do how Emacs compiles Lisp into native code.

** Header

#+begin_src emacs-lisp
  ;;; early-init.el --- My Emacs Early Init File -*- lexical-binding: t -*-

  ;; This file is not part of GNU Emacs

  ;; This program is free software: you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.

  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.

  ;; You should have received a copy of the GNU General Public License
  ;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

  ;;; Code:
#+end_src

** GUI

#+begin_src emacs-lisp
  ;; Prevent Emacs from loading system window decorations.
  ;; (add-to-list 'default-frame-alist '(undecorated-round . t))
  (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
  (setopt ns-use-proxy-icon nil)
  (setopt frame-title-format nil)

  ;; Remove outer padding from Emacs frame.
  (setopt frame-resize-pixelwise t)

  ;; Disable scroll-bar, tool-bar, start-up greeting message, and the help
  ;; message at the top of Scratch buffers.
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (setopt inhibit-startup-message t)
  (setopt initial-scratch-message nil)
#+end_src

** Native Compilation

#+begin_src emacs-lisp
  (when (featurep 'native-compile)
    (setopt native-comp-async-report-warnings-errors nil)
    (setopt native-comp-deferred-compilation t))

  ;; Designate a folder to collect all of the .eln files generated by
  ;; native compilation. (This is recommended by the configuration for the
  ;; no-litering package, which itself is configured in my init.el.)
  (when (and (fboundp 'startup-redirect-eln-cache)
             (fboundp 'native-comp-available-p)
             (native-comp-available-p))
    (startup-redirect-eln-cache
     (convert-standard-filename
      (expand-file-name "var/eln-cache/" user-emacs-directory))))
#+end_src

** Footer

#+begin_src emacs-lisp
  (provide 'early-init)

  ;;; early-init.el ends here
#+end_src

* init.el
:PROPERTIES:
:header-args: :tangle init.el
:END:
** Header

#+begin_src emacs-lisp
  ;;; init.el --- My Emacs Init File -*- lexical-binding: t -*-

  ;; This file is not part of GNU Emacs

  ;; This program is free software: you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.

  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.

  ;; You should have received a copy of the GNU General Public License
  ;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

  ;;; Code:
#+end_src

** Paths and packages
*** no-littering

#+begin_src emacs-lisp
  (use-package no-littering
    :init
    (eval-and-compile ; Ensure values don't differ at compile time.
      (setq no-littering-etc-directory
            (expand-file-name "etc/" user-emacs-directory))
      (setq no-littering-var-directory
            (expand-file-name "var/" user-emacs-directory)))
    :config
    (no-littering-theme-backups)
    (setq custom-file
          (expand-file-name "custom.el" user-emacs-directory)))
#+end_src

*** Package archives

#+begin_src emacs-lisp
  (use-package package
    :ensure nil
    :config
    (add-to-list 'package-archives ; the default list contains ELPA and non-GNU ELPA
                 '("melpa" . "https://melpa.org/packages/") t))
#+end_src

*** exec-path-from-shell

#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :if (memq window-system '(mac ns))
    :config
    (exec-path-from-shell-initialize))
#+end_src

** Miscellaneous preferences

#+begin_src emacs-lisp
  (setopt visible-bell t)
  (setopt confirm-kill-emacs 'yes-or-no-p)
  (setopt use-short-answers t)
  (setopt use-dialog-box nil)
  (setopt use-file-dialog nil)
  (setopt kill-buffer-query-functions
          ;; Disable query when kiling buffers with running processes.
          (remq 'process-kill-buffer-query-function
                kill-buffer-query-functions))
  (setopt delete-old-versions t)
  (setopt help-window-select t)
#+end_src

*** GUI, faces, and fonts
**** ultra-scroll

#+begin_src emacs-lisp
  (use-package ultra-scroll
    ;; :ensure t
    :init
    (setq scroll-conservatively 101 ; important!
          scroll-margin 0)
    :config
    (ultra-scroll-mode 1))
#+end_src

**** Mode-line
***** minions

#+begin_src emacs-lisp
  (use-package minions
    :custom
    (minions-mode-line-delimiters nil)
    :config
    (minions-mode 1))
#+end_src
***** mood-line

#+begin_src emacs-lisp
  (use-package mood-line
    :disabled
    :after minions
    :preface
    (defun my/mood-line-segment-major-mode ()
      "Return the name of the major mode of the current buffer."
      (concat (format-mode-line minions-mode-line-modes 'mood-line-major-mode) ""))
    :custom
    (mood-line-glyph-alist mood-line-glyphs-unicode)
    (mood-line-format
     (mood-line-defformat
      :left
      (((mood-line-segment-buffer-status) . " ")
       ((mood-line-segment-buffer-name)   . " : ")
       (my/mood-line-segment-major-mode)
       (mood-line-segment-vc)         . "  ")
      :right
      (((mood-line-segment-scroll)             . " ")
       ((mood-line-segment-cursor-position)    . "  ")
       ((when (mood-line-segment-checker) "|") . "  ")
       ((mood-line-segment-checker)            . "  ")))
    :config
    (mood-line-mode)))

#+end_src

**** Fonts and other styles

#+begin_src emacs-lisp
  ;; (when (member "Input Mono Narrow" (font-family-list))
  ;;   (set-face-attribute 'default nil :font "Input Mono Narrow" :height 120)
  ;;   (set-face-attribute 'fixed-pitch nil :font "Input Mono Narrow"))

  (when (member "JetBrains Mono" (font-family-list))
    (set-face-attribute 'default nil :font "JetBrains Mono" :height 120)
    (set-face-attribute 'fixed-pitch nil :font "JetBrains Mono"))
#+end_src

***** mixed-pitch-mode

#+begin_src emacs-lisp
  (use-package mixed-pitch
    :disabled
    :hook
    ;; If you want it in all text modes:
    (text-mode . mixed-pitch-mode))
#+end_src

***** info-variable-pitch

#+begin_src emacs-lisp
  (use-package info-variable-pitch
    :hook (info-mode . info-variable-pitch-mode))
#+end_src

** Keyboard, keybinds, keymaps


With a laptop keyboard you have to be inventive if you want ergonomic modifier keys in Emacs. Here is one way to create a symmetrical layout on a Macbook Air keyboard with Control keys at either end of the homerow and Super and Meta keys under each thumb.

| Macbook keys | Karabiner   |             | Emacs   |
|--------------+-------------+-------------+---------|
|              | On press    | On hold     |         |
|--------------+-------------+-------------+---------|
| esc          | esc         | (R) option  | nil     |
| caps lock    |             | (L) control | Control |
| return       | return      | (L) control | Control |
| (L) control  | (R) control | (R) control | Hyper   |
| (L) option   | (L) option  | (L) option  | Meta    |
| (L) command  | (L) command | (L) command | Super   |
| (R) command  | (R) command | (R) command | Super   |
| (R) option   | (L) option  | (L) option  | Meta    |
|              |             |             |         |

In the far left column are keys or keycodes as they are defined by the Macbook at the hardware and system level. In the two middle columns are the corresponding remappings as we configure them in Karabiner. The middle left column contains the keycodes sent by the physical keys when they are pressed individually. (It would be more precise to say when they are pressed and released before another key is pressed.) In the middle right column we see the keycodes sent by the physical keys when they are pressed and held in combination with another key press. Finally in the far right column are the modifier keys assigned within Emacs to the keycodes just described.

A few more things are worth pointing out. The Macbook Air keyboard has an Option key and a Command key on either side of the spacebar. This is great because it means that each thumb can have equal access to a Meta key anD Super key. But this creates a problem because, by redefining the two Option keys as Meta keys in Emacs we lose access within Emacs to the dead key and alternate character map that the OS puts behind the Option keys. The way around this is to unbind one of the Option keys and assign it the keycode of the other Option key. (This is possible because MacOS in fact distinguishes between right and left modifier keycodes.) Using Karabiner, we configure the two Option keys to send the same keycode to the OS (in this case, ~left_option~ in Karabiner's notation) and remap the remaining keycode (in this case, ~right_option~) to a different (physical) key, such as Escape. Then within Emacs we disable ~right_option~ as a modifier key so that we are able to send the ~right_option~ keycode—and which we no longer need for the Meta key—to the OS without Emacs getting in the way because it thinks we are pressing Meta.

We can also use the existence of left and right modifiers to set up the physical Control key as a Hyper modifier key within Emacs. First, we make sure that when we want to post the Control keycode we are only sending ~left_control~. Then we map the ~right_control~ keycode onto the lone physical Control key. Finally, we tell tell Emacs to interpret ~right_control~ as the Hyper modifier key.

*** Karabiner

Below is my configuration for Karabiner in order to achieve the layout described above. This source block tangles to ~karabiner.json~ in my dotfiles. (This is of course has nothing to do with Emacs. I include the ~json~ file here because it's convenient to do so.)

#+begin_src json :tangle no :tangle ~/.config/karabiner/karabiner.json
  {
      "profiles": [
          {
              "complex_modifications": {
                  "rules": [
                      {
                          "description": "esc: escape when pressed alone and right_option when held",
                          "manipulators": [
                              {
                                  "from": {
                                      "key_code": "escape",
                                      "modifiers": { "optional": ["any"] }
                                  },
                                  "to": [{ "key_code": "right_option" }],
                                  "to_if_alone": [{ "key_code": "escape" }],
                                  "type": "basic"
                              }
                          ]
                      },
                      {
                          "description": "return: return when pressed alone and left_control when held",
                          "manipulators": [
                              {
                                  "from": {
                                      "key_code": "return_or_enter",
                                      "modifiers": { "optional": ["any"] }
                                  },
                                  "to": [{ "key_code": "left_control" }],
                                  "to_if_alone": [{ "key_code": "return_or_enter" }],
                                  "type": "basic"
                              }
                          ]
                      }
                  ]
              },
              "name": "Macbook Air M3 2024",
              "selected": true,
              "simple_modifications": [
                  {
                      "from": { "key_code": "caps_lock" },
                      "to": [{ "key_code": "left_control" }]
                  },
                  {
                      "from": { "key_code": "left_control" },
                      "to": [{ "key_code": "right_control" }]
                  },
                  {
                      "from": { "key_code": "right_option" },
                      "to": [{ "key_code": "left_option" }]
                  }
              ],
              "virtual_hid_keyboard": { "keyboard_type_v2": "ansi" }
          }
      ]
  }
#+end_src

**** modifiers keys on macos

#+begin_src emacs-lisp
  (use-package ns-win
    :when (eq system-type 'darwin)
    :init
    (setopt mac-command-modifier 'super
            mac-option-modifier 'meta
            mac-right-option-modifier 'nil
            mac-right-control-modifier 'hyper))
#+end_src

*** free-keys

#+begin_src emacs-lisp
  (use-package free-keys
    :custom
    (free-keys-modifiers '("" "C" "M" "C-M" "s" "H")))
#+end_src

*** Prefix maps

#+begin_src emacs-lisp
  (use-package emacs
    :bind
    (:map global-map
          :prefix-map my-ctrl-z-prefix-map
          :prefix "C-z")
    (:map global-map
          :prefix-map my-super-c-prefix-map
          :prefix "s-c")
    (:map global-map
          :prefix-map my-super-x-prefix-map
          :prefix "s-x")
    (:map global-map
          :prefix-map my-super-z-prefix-map
          :prefix "s-z")
    (:map global-map
          :prefix-map my-global-narrow-prefix-map
          :prefix "s-v"
          :prefix-docstring
          "Prefix map for narrowing commands."
          ("n" . narrow-to-region)
          ("d" . narrow-to-defun)
          ("p" . narrow-to-page)
          ("w" . widen)))
#+end_src

** Completion and the minibuffer
*** Save recent files
#+begin_src emacs-lisp
  (use-package recentf
    :ensure nil
    :config
    ;; (setq recentf-exclude '("COMMIT_MSG" "COMMIT_EDITMSG" "github.*txt$"
    ;;                         "[0-9a-f]\\{32\\}-[0-9a-f]\\{32\\}\\.org"
    ;;                         ".*png$" ".*cache$"))
    (setq recentf-max-saved-items 500))
#+end_src

*** Save minibuffer history
#+begin_src emacs-lisp
  (use-package savehist
    :ensure nil
    :init
    (savehist-mode))
#+end_src

*** vertico

#+begin_src emacs-lisp
  (use-package vertico
    :hook ((after-init . vertico-mode)
           (vertico-mode . vertico-multiform-mode)))
#+end_src

*** consult

#+begin_src emacs-lisp
  (use-package consult
    :ensure t
    :bind
    (;; C-c bindings in `mode-specific-map'
     ("C-c M-x" . consult-mode-command)
     ("C-c h" . consult-history)
     ("C-c k" . consult-kmacro)
     ("C-c m" . consult-man)
     ("C-c i" . consult-info)
     ([remap Info-search] . consult-info)
     ;; C-x bindings in `ctl-x-map'
     ("C-x M-:" . consult-complex-command) ;; †repeat-complex-command
     ("C-x b" . consult-buffer)		 ;; †switch-to-buffer
     ("s-b" . consult-buffer)		 ;; †switch-to-buffer
     ("C-x 4 b" . consult-buffer-other-window) ;; †switch-to-buffer-other-window
     ("C-x 5 b" . consult-buffer-other-frame) ;; †switch-to-buffer-other-frame
     ("C-x t b" . consult-buffer-other-tab) ;; †switch-to-buffer-other-tab
     ("C-x r b" . consult-bookmark)	  ;; †bookmark-jump
     ("C-x p b" . consult-project-buffer)	  ;; †project-switch-to-buffer
     ;; Custom M-# bindings for fast register access
     ("M-#" . consult-register-load)
     ("M-'" . consult-register-store) ;; †abbrev-prefix-mark (unrelated)
     ("C-M-#" . consult-register)
     ;; Other custom bindings
     ("M-y" . consult-yank-pop) ;; †yank-pop
     ;; M-g bindings in `goto-map'
     ("M-g e" . consult-compile-error)
     ("M-g f" . consult-flymake)
     ("M-g g" . consult-goto-line)	 ;; †goto-line
     ("M-g M-g" . consult-goto-line)	 ;; †goto-line
     ("M-g o" . consult-outline)
     ("M-g m" . consult-mark)
     ("M-g k" . consult-global-mark)
     ("M-g i" . consult-imenu)
     ("M-g I" . consult-imenu-multi)
     ;; M-s bindings in `search-map'
     ("M-s d" . consult-find)
     ("M-s c" . consult-locate)
     ("M-s g" . consult-grep)
     ("M-s G" . consult-git-grep)
     ("M-s r" . consult-ripgrep)
     ("M-s l" . consult-line)
     ("M-s L" . consult-line-multi)
     ("M-s k" . consult-keep-lines)
     ("M-s u" . consult-focus-lines)
     ;; Isearch integration
     ("M-s e" . consult-isearch-history)
     :map isearch-mode-map
     ("M-e" . consult-isearch-history)         ;; †isearch-edit-string
     ("M-s e" . consult-isearch-history)       ;; †isearch-edit-string
     ("M-s l" . consult-line) ;; needed by consult-line to detect isearch
     ("M-s L" . consult-line-multi) ;; needed by consult-line to detect isearch
     ;; Minibuffer history
     :map minibuffer-local-map
     ("M-s" . consult-history)	   ;; †next-matching-history-element
     ("M-r" . consult-history)	   ;; †previous-matching-history-element
     ;; Other commands
     ("C-x C-r" . consult-recent-file)) ;; †find-file-read-only

    :hook
    ;; Enable automatic preview at point in the *Completions* buffer.
    (completion-list-mode . consult-preview-at-point-mode)

    :init
    ;; Optionally configure the register formatting.
    (setq register-preview-delay 0.5
          register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode-line of the window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    :config
    (consult-customize
     consult-theme :preview-key '(:debounce 0.2 any)
     consult-ripgrep consult-git-grep consult-grep
     consult-bookmark consult-recent-file consult-xref
     consult--source-bookmark consult--source-file-register
     consult--source-recent-file consult--source-project-recent-file
     :preview-key '(:debounce 0.4 any))	; :preview-key "M-."
    (setq consult-narrow-key "<"))
#+end_src

*** embark

#+begin_src emacs-lisp
  (use-package embark
    :ensure t
    :bind (("s-," . embark-act)		; †customize
           ("s-." . embark-dwim)
           ("C-h B" . embark-bindings))

    :config
    ;; Hide mode-line in embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none)))))

  (use-package embark-consult
    :ensure t
    :after embark
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

*** orderless

#+begin_src emacs-lisp
  (use-package orderless
    :ensure t
    :custom
    (completion-styles '(orderless basic))
    (completion-category-defaults nil)
    (completion-category-overrides '((file (styles partial-completion)))))
#+end_src

*** corfu

#+begin_src emacs-lisp
  (use-package corfu
    :ensure t
    :init
    (global-corfu-mode)
    :custom
    ;; Enable indentation+completion using the TAB key.
    ;; `completion-at-point' is often biound to M-TAB.
    (tab-always-indent 'complete)
    ;; Hide commands in M-x which do not apply to the current mode.  Corfu
    ;; commands are hidden, since they are not used via M-x. This setting is
    ;; useful beyond Corfu.
    (read-extended-command-predicate #'command-completion-default-include-p))
#+end_src

*** marginalia

#+begin_src emacs-lisp
  (use-package marginalia
    :ensure t
    :bind
    (:map minibuffer-local-map
          ("M-A" . marginalia-cycle))
    :init
    (marginalia-mode))
#+end_src

*** which-key

#+begin_src emacs-lisp
  (use-package which-key
    :ensure t 				; must be nil on Emacs 30+
    :config
    (which-key-mode))
#+end_src

*** yasnippet

#+begin_src emacs-lisp
  (use-package yasnippet
    :ensure t
    :config
    (yas-global-mode 1)
    :bind ("H-s" . yas-insert-snippet))

  (use-package yasnippet-snippets
    :ensure t
    :after yasnippet
    :pin gnu)
#+end_src

*** dabbrev/hippie-expand

#+begin_src emacs-lisp
  (use-package hippie-exp
    :bind ([remap dabbrev-expand] . hippie-expand))
#+end_src

*** tempel

#+begin_src emacs-lisp
  (use-package tempel
    :disabled
    :ensure t
    :preface
    (defun tempel-setup-capf ()
      ;; Add the Tempel Capf to `completion-at-point-functions'.
      ;; `tempel-expand' only triggers on exact matches. Alternatively use
      ;; `tempel-complete' if you want to see all matches, but then you
      ;; should also configure `tempel-trigger-prefix', such that Tempel
      ;; does not trigger too often when you don't expect it. NOTE: We add
      ;; `tempel-expand' *before* the main programming mode Capf, such
      ;; that it will be tried first.
      (setq-local completion-at-point-functions
                  (cons #'tempel-expand
                        completion-at-point-functions)))
    (add-hook 'conf-mode-hook 'tempel-setup-capf)
    (add-hook 'prog-mode-hook 'tempel-setup-capf)
    (add-hook 'text-mode-hook 'tempel-setup-capf)
    :custom
    (tempel-trigger-prefix ",")
    (tempel-path (locate-user-emacs-file "etc/templates/tempo.eld"))
    :bind (("s-\\" . tempel-complete)
           ("s-|" . tempel-insert)
           :map tempel-map
           ([tab] . tempel-next)
           ([backtab] . tempel-previous)))
#+end_src

**** Templates

#+begin_src emacs-lisp :tangle no :tangle (locate-user-emacs-file "etc/templates/tempo.eld")
  emacs-lisp-mode

  (usep "(use-package " p n> ":ensure " p ")" n>)

  js-base-mode typescript-ts-base-mode

  (ccl "console.log(" p ")" p)
  (ffun "function (" p ") {" n> p n> "}")
  (ffor "for (" p ") {" n> p n> "}")
  (iff  "if (" p ") {" n> p n> "}" )
#+end_src

***** tempel-collection

#+begin_src emacs-lisp
  (use-package tempel-collection
    :disabled
    :ensure t
    :after tempel)
#+end_src

** Windows, buffers, and tabs
*** Line-wrapping

#+begin_src emacs-lisp
  (global-visual-line-mode 1)

  (use-package display-fill-column-indicator
    :ensure nil
    :custom (display-fill-column-indicator-character nil)
    :custom-face (fill-column-indicator
                  ((t (:height 1.0 :foreground "grey"))))
    :hook (prog-mode . display-fill-column-indicator-mode))
#+end_src

*** tab-bar
#+begin_src emacs-lisp
  (use-package tab-bar
    :custom ((tab-bar-show nil)
             (tab-bar-auto-width nil)
             (tab-bar-select-tab-modifiers '(super))
             (tab-bar-close-button-show nil)))


  ;; (setopt tab-bar-show nil) ; on customize-set-variable see https://emacs.stackexchange.com/a/106
  ;; (setq tab-bar-close-button-show nil)       ;; hide tab close / X button
  ;; (setq tab-bar-tab-hints nil) ;; show tab numbers
  ;; (setq tab-bar-format '(tab-bar-format-tabs tab-bar-separator)) ;; elements to include in bar

#+end_src

*** activities

#+begin_src emacs-lisp
  (use-package activities
    :init
    (activities-mode)
    (activities-tabs-mode)
    :bind
    ("H-b" . activities-switch-buffer)
    ("H-/" . activities-revert)
    ("H-z" . activities-switch)
    (:map global-map
          :prefix-map my-activities-prefix-map
          :prefix "H-a"
          :prefix-docstring
          "Prefix keymap for activities-mode."
          ("n" . activities-new)
          ("d" . activities-define)
          ("a" . activities-resume)
          ("s" . activities-suspend)
          ("k" . activities-kill)
          ("RET" . activities-switch)
          ("b" . activities-switch-buffer)
          ("g" . activities-revert)
          ("l" . activities-list)))
#+end_src

*** popper

#+begin_src emacs-lisp
  (use-package popper
    :ensure t
    :bind (("H-`"   . popper-toggle)
           ("H-<tab>"   . popper-cycle)
           (:map popper-mode-map
                 ("H-~" . popper-toggle-type)))
    :custom
    ;; specify buffer types for popper to control
    (popper-reference-buffers '("Output\\*$"
                                "\\*Async Shell Command\\*"
                                help-mode
                                compilation-mode
                                ;; and suppress or hide some of them
                                ("\\*Messages\\*" . hide)
                                ("\\*Warnings\\*" . hide)))
    :hook
    (after-init . popper-mode)
    (After-init . popper-echo-mode))
#+end_src

*** winner-mode

#+begin_src emacs-lisp
  (use-package winner
    :hook (after-init . winner-mode)
    :bind (("s-/" . winner-undo)
           ("s-?" . winner-redo))
    :custom
    (winner-dont-bind-my-keys t)
    (winner-boring-buffers '("*Completions*"
                             "*Compile-Log*"
                             "*inferior-lisp*"
                             "*Fuzzy Completions*"
                             "*Apropos*"
                             "*Help*"
                             "*Buffer List*"
                             "*Ibuffer*"
                             "*Warnings*"
                             "*Messages*"
                             "*Activities (error)")))
#+end_src

*** windmove

#+begin_src emacs-lisp
  (use-package windmove
    :config
    (windmove-default-keybindings 'hyper)
    (windmove-swap-states-default-keybindings '(hyper shift)))

  ;; (windmove-delete-default-keybindings)
  ;; (windmove-display-default-keybindings)
#+end_src

*** fwb-cmds

#+begin_src emacs-lisp
  (use-package fwb-cmds
    :ensure t
    :bind ("s-'" . fwb-toggle-window-split)) ; †next-window-any-frame
#+end_src

*** ace-window

#+begin_src emacs-lisp
  (use-package ace-window
    :ensure t
    :demand
    :bind ("M-o" . ace-window)
    :custom
    (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))
#+end_src

*** Ibuffer

#+begin_src emacs-lisp
  (use-package ibuffer
    :ensure nil
    :bind ([remap list-buffers] . ibuffer)) ; C-x C-b

  (use-package ibuffer-vc
    :after ibuffer)
#+end_src

*** olivetti-mode

#+begin_src emacs-lisp
  (use-package olivetti)
#+end_src

** Editing and buffer navigation

More ergonomic binding for beginning/end of buffer:
#+begin_src emacs-lisp
  (bind-key "s-a" 'beginning-of-buffer)
  (bind-key "s-e" 'end-of-buffer)
#+end_src

write-region binding:
#+begin_src emacs-lisp
  (bind-keys :prefix-map my-hyper-x-prefix-map
             :prefix "H-x"
             ("f" . write-region))
#+end_src

#+begin_src emacs-lisp
  (use-package misc
    :ensure nil
    :bind
    ;; Rebind 'M-z' as 'zap-up-to-char'. 'zap-to-char' is still available
    ;; at 'M-Z'. But see 'avy-zap' further below.
    ("M-z" . zap-up-to-char)
    ("s-y" . duplicate-dwim))		; †ns-paste-secondary
#+end_src

*** goto-chg

#+begin_src emacs-lisp
  (use-package goto-chg
    :ensure t
    :bind (:map my-super-c-prefix-map
           ("s-j" . goto-last-change)))
#+end_src

*** move-text

#+begin_src emacs-lisp
  (use-package move-text
    :ensure t
    :bind (("s-p" . move-text-up)
           ("s-n" . move-text-down)))
#+end_src

*** comment-dwim-2

#+begin_src emacs-lisp
  (use-package comment-dwim-2
    :ensure t
    :demand
    :bind
    ("s-;" . comment-dwim-2))
#+end_src

*** ws-butler

#+begin_src emacs-lisp
  (use-package ws-butler
    :ensure t
    :hook ((text-mode . ws-butler-mode)
           (prog-mode . ws-butler-mode)))
#+end_src

*** avy

#+begin_src emacs-lisp
  (use-package avy
    :ensure t
    :bind
    ("s-q" . avy-goto-char-timer))
#+end_src

**** avy-zap

#+begin_src emacs-lisp
  (use-package avy-zap
    :after avy
    :ensure t
    :bind
    ([remap zap-up-to-char] . avy-zap-up-to-char-dwim)
    ([remap zap-to-char] . avy-zap-to-char-dwim))
#+end_src

*** ace-link

#+begin_src emacs-lisp
  (use-package ace-link
    :ensure t
    :config
    (ace-link-setup-default))
#+end_src

*** vundo

#+begin_src emacs-lisp
  (use-package vundo
    :ensure t
    :bind (("C-x u" . vundo)
           ("H-/" . vundo)))
#+end_src

*** expand-region

#+begin_src emacs-lisp
  (use-package expand-region
    :ensure t
    :bind
    ("s-=" . er/expand-region)
    ("s--" . er/contract-region))
#+end_src

*** denote

#+begin_src emacs-lisp
  (use-package denote

    :bind (("C-c n n" . denote)
	   ("C-c n s" . denote-subdirectory)
	   ("C-c n i" . denote-link)
	   ("C-c n l" . denote-link-find-file)
	   ("C-c n b" . denote-link-backlinks))
    :hook
    (dired-mode . denote-dired-mode)
    :custom
    (denote-directory "~/notes/"))

  (use-package consult-denote

    :bind (("C-c n f" . consult-denote-find)
	   ("C-c n g" . consult-denote-grep))
    :config
    (consult-denote-mode 1))
#+end_src

** Programming

#+begin_src emacs-lisp
  (use-package elec-pair
    :ensure nil
    :hook ((js-mode python-mode) . electric-pair-mode))
#+end_src

*** paredit

#+begin_src emacs-lisp
  (use-package paredit
    :ensure t
    :demand
    :hook ((emacs-lisp-mode . paredit-mode)
           (lisp-mode . paredit-mode)
           (lisp-interaction-mode . paredit-mode)
           (eval-expression-minibuffer-setup . paredit-mode)))
#+end_src

*** tree-sitter

#+begin_src emacs-lisp
  (use-package tree-sitter
    )
#+end_src

**** tree-sitter-langs

#+begin_src emacs-lisp
  (use-package tree-sitter-langs

    :after tree-sitter
    :config
    (tree-sitter-langs-install-grammars :skip-if-installed))
#+end_src

**** treesit-auto

#+begin_src emacs-lisp
  (use-package treesit-auto
    :after tree-sitter
    :custom
    (treesit-auto-install 'prompt)
    :config
    (treesit-auto-add-to-auto-mode-alist 'all)
    (global-treesit-auto-mode))
#+end_src

*** python

#+begin_src emacs-lisp
  (use-package python
    :preface
    ;; Define commands to toggle between buffer and shell. From https://www.masteringemacs.org/article/toggling-python-buffers
    (defvar python-last-buffer nil
      "Name of the Python buffer that last invoked `toggle-between-python-buffers'")

    (make-variable-buffer-local 'python-last-buffer)

    (defun toggle-between-python-buffers ()
      "Toggles between a `python-mode' buffer and its inferior Python process

  When invoked from a `python-mode' buffer it will switch the
  active buffer to its associated Python process. If the command is
  invoked from a Python process, it will switch back to the `python-mode' buffer."
      (interactive)
      ;; check if `major-mode' is `python-mode' and if it is, we check if
      ;; the process referenced in `python-buffer' is running
      (if (and (eq major-mode 'python-mode)
               (processp (get-buffer-process python-buffer)))
          (progn
            ;; store a reference to the current *other* buffer; relying
            ;; on `other-buffer' alone wouldn't be wise as it would never work
            ;; if a user were to switch away from the inferior Python
            ;; process to a buffer that isn't our current one.
            (switch-to-buffer python-buffer)
            (setq python-last-buffer (other-buffer)))
        ;; switch back to the last `python-mode' buffer, but only if it
        ;; still exists.
        (when (eq major-mode 'inferior-python-mode)
          (if (buffer-live-p python-last-buffer)
              (switch-to-buffer python-last-buffer)
            ;; buffer's dead; clear the variable.
            (setq python-last-buffer nil)))))

    (unbind-key "s-o")
    :mode ("\\.py\\'" . python-ts-mode)
    ;; :hook (python-ts-mode (lambda () (run-hooks 'python-mode-hook)))
    :custom
    (fill-column 72)
    (python-indent-offset 4)
    (python-shell-completion-native-enable nil) ; see https://emacs.stackexchange.com/questions/30082/your-python-shell-interpreter-doesn-t-seem-to-support-readline

    :bind (:map python-mode-map ("s-o" . toggle-between-python-buffers)
           :map inferior-python-mode-map ("s-o" . toggle-between-python-buffers)))
#+end_src

**** py-vterm

#+begin_src emacs-lisp
  (use-package py-vterm-interaction
      :hook (python-mode . py-vterm-interaction-mode)
      :custom
      (py-vterm-interaction-repl-program "ipython -i")
      (py-vterm-interaction-silent-cells t))
#+end_src

*** racket

#+begin_src emacs-lisp
  (use-package racket-mode
    :ensure t
    :mode("\\.rkt?\\'" . racket-mode)
    :custom (racket-program "/Applications/Racket v8.15/bin/racket"))
#+end_src

*** javascript

#+begin_src emacs-lisp
  (use-package js-mode
    :ensure nil
    :mode "\\.js\\'")
#+end_src

**** nodejs-repl
#+begin_src emacs-lisp
  (use-package nodejs-repl
    :ensure t
    :if (executable-find "node")
    :bind (:map js-mode-map
                ("C-c C-z" . nodejs-repl-switch-to-repl)
                ("C-x C-e" . nodejs-repl-send-last-expression)
                ("C-c C-b" . nodejs-repl-send-buffer)
                ("C-c C-r" . nodejs-repl-send-region))
    :hook ((js-mode js-ts-mode) . nodejs-repl-minor-mode))
#+end_src

*** json

#+begin_src emacs-lisp
  (use-package json-mode
    :ensure t
    :mode "\\.json\\'")
#+end_src

** Org-mode

#+begin_src emacs-lisp
  (use-package org
    :custom
    (org-startup-indented t)
    (org-ellipsis " …")
    ;; Remove underline from org-ellipsis just defined.
    (set-face-underline 'org-ellipsis nil)
    (org-catch-invisible-edits 'show-and-error)
    (org-special-ctrl-a/e t)
    (org-insert-heading-respect-content t)
    (org-hide-emphasis-markers t)
    (org-pretty-entities t)
    :hook (org-mode . visual-line-mode)
    :bind
    ("H-o t" . org-babel-tangle-file)
    (:prefix-map my-org-narrowing-prefix-map
                 :prefix "s-n"
                 :prefix-docstring
                 "Prefix map for narrowing commands in Org-mode."
                 ("s" . org-narrow-to-subtree)
                 ("b" . org-narrow-to-block)
                 ("w" . widen)))
#+end_src

**** org-modern

#+begin_src emacs-lisp
  (use-package org-modern
    :after org
    :custom
    (org-modern-hide-stars nil)		; adds extra indentation
    (org-modern-block-name '("" . ""))
    (org-modern-fold-stars
     '(("►" . "▼") ("►" . "▼") ("►" . "▼") ("►" . "▼") ("►" . "▼")))
    :hook
    (org-mode . org-modern-mode))
#+end_src

***** org-modern-indent

#+begin_src emacs-lisp
  (use-package org-modern-indent
    :after org-modern
    :config ; add late to hook
    (add-hook 'org-mode-hook #'org-modern-indent-mode 90))
#+end_src

**** org-tidy

#+begin_src emacs-lisp
  (use-package org-tidy
    :disabled
    :hook
    (org-mode . org-tidy-mode))
#+end_src

** Documents: reading, writing, exporting
*** pdf-tools

#+begin_src emacs-lisp
  (use-package pdf-tools

    :pin manual ;; manually update
    :mode  ("\\.[pP][dD][fF]\\'" . pdf-view-mode)
    :bind (:map pdf-view-mode-map
                ("C-s" . isearch-forward))
    ;; :init
    ;; (pdf-loader-install)
    :config
    (pdf-loader-install)
    ;; (pdf-tools-install :no-query)
    ;; open pdfs scaled to fit page
    (setq-default pdf-view-display-size 'fit-width))
#+end_src
*** nov.el

#+begin_src emacs-lisp
  (use-package nov
    :ensure t
    :mode ("\\.epub\\'" . nov-mode))
#+end_src

*** typst

Present configuration requires https://github.com/Myriad-Dreamin/tinymist.

**** typst-ts-mode

#+begin_src emacs-lisp
  (use-package typst-ts-mode
    ;; https://codeberg.org/meow_king/typst-ts-mode
    :custom
    (typst-ts-watch-options "--open")
    (typst-ts-mode-grammar-location (expand-file-name "tree-sitter/libtree-sitter-typst.so" user-emacs-directory))
    (typst-ts-mode-enable-raw-blocks-highlight t)
    :config
    (keymap-set typst-ts-mode-map "C-c C-c" #'typst-ts-tmenu)
    ;; The remaining lines are suggested by typst-preview.
    ;; (add-to-list 'lsp-language-id-configuration '(typst-ts-mode . "typst"))
    ;; (lsp-register-client
    ;;  (make-lsp-client
    ;;   :new-connection (lsp-stdio-connection "typst-lsp")
    ;;   :major-modes '(typst-ts-mode)
    ;;   :server-id 'typst-lsp))
    )
#+end_src

**** typst-preview

#+begin_src emacs-lisp
  (use-package typst-preview
    ;; https://github.com/havarddj/typst-preview.el
    :config
    (setq typst-preview-browser "xwidget")
    (define-key typst-preview-mode-map (kbd "C-c C-j") 'typst-preview-send-position))
#+end_src

** Version control and file management
*** dired

#+begin_src emacs-lisp
  (use-package dired
    :ensure nil
    :custom
    (delete-by-moving-to-trash t)
    (dired-dwim-target t)
    (load-prefer-newer t))

  (use-package dired-aux
    :ensure nil
    :after dired)

  (use-package dired-x
    :ensure nil
    :disabled
    :after dired-aux
    :hook
    (dired-mode . dired-omit-mode)
    :custom
    (dired-omit-extensions ".DS_Store")
    (dired-find-subdir t))

  (use-package dired-plus
    :ensure t
    :disabled
    :after dired-x)
#+end_src

*** magit
#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :bind ("H-g" . magit-status))
#+end_src

** Unsorted
*** websocket

#+begin_src emacs-lisp
  (use-package websocket
    :ensure t)
#+end_src

** Footer

#+begin_src emacs-lisp
  (provide 'init)

  ;;; init.el ends here
#+end_src
